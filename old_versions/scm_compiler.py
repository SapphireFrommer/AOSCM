import datetime

def header_comment(text, param, module_scm_text):
    text.append('/*\n')
    text.append('###############################################################\n')
    text.append('#\tGenerated by:\t\tEnICS SCM Compiler v1.0\n')
    text.append('#\tGenerated on:\t\t'+str(datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"))+'\n')
    text.append('#\tDesign:\t\t\t\t'+param['TOPLEVEL']+'\n')
    text.append('#\n')
    text.append('#\tDimensions:\n')
    text.append('#\tDATA WIDTH:\t\t\t'+str(param['DATA_WIDTH'])+'\n')
    text.append('#\tNUM ROWS:\t\t\t'+str(2**param['ADDR_WIDTH'])+'\n')
    text.append('#\n')
    text.append('#\tlines in lists:\n')    
    text.append('#\tmodule_scm_text:\t'+str(len(module_scm_text))+'\n')
    text.append('###############################################################\n')
    text.append('*/\n\n')    
    

def main():
    ####################### define parameter #######################
    param = {}
    param['TOPLEVEL'] = "scm65"
    param['DATA_WIDTH'] = 8
    param['ADDR_WIDTH'] = 2

    cell = {}       # a dictionary of all cells

    cell['latch'] = {}
    cell['latch']['name'] = "LATQ_X1M_A12TR"
    cell['latch']['enable'] = "G"
    cell['latch']['input'] = "D"
    cell['latch']['output'] = "Q"
    cell['latch']['size'] = 3.0
    
    
    cell['GWCLK'] = {}
    cell['GWCLK']['name'] = "PREICG_X0P5B_A12TR"

    ################################################################
    #--------------------------------------------------------------#
    ######################### data base ############################
    inst = {}       # a dictionary of all instances (data base)
    
    inst['MemoryLatch_reg'] = {}
    inst['MemoryLatch_reg']['cell'] = 'latch'
    inst['MemoryLatch_reg']['enable'] = 'DGWClkLeftNet_0'
    inst['MemoryLatch_reg']['input'] = 'GDIN[0]'
    inst['MemoryLatch_reg']['output'] = 'MemoryLatch_0[0])'
    inst['MemoryLatch_reg']['x_coords'] = 2.0
    inst['MemoryLatch_reg']['y_coords'] = 5.3
    

    class inst:
        def __init__(self):
            self.cell = None
            self.x_coords = None
            self.y_coords = None
         
        def __str__(self):
            return 'cell = '+str(self.cell)+'\nx_coords = '\
                +str(self.x_coords)+'\ny_coords = '+str(self.y_coords)

    class latch(inst):
        def __init__(self):
            inst.__init__(self)
            self.enable = None
            self.input = None
            self.output = None

        def __str__(self):
            return inst.__str__(self)+'\nenable = '+str(self.enable)+'\ninput = ' \
                +str(self.input)+'\noutput = '+str(self.output)
        

    ################################################################

    verilog_file_name = "%s.post_py.v" %param['TOPLEVEL']
    tcl_file_name = '%s_cells_position.tcl' %param['TOPLEVEL']
    
    header_comment_text = []
    module_scm_text = []    # list for lines in module scm text

    write_module_scm(module_scm_text, param , cell)
    header_comment(header_comment_text, param, module_scm_text)    

    verilog_file=open(verilog_file_name,'w')
    
    #f.write(''.join(text))
    for line in header_comment_text:
        verilog_file.write(line)
    # write module_scm_text
    for line in module_scm_text:
        verilog_file.write(line)
    verilog_file.close()


def write_module_scm(text, param , cell):
    # define simple name local parameter
    TOPLEVEL = param['TOPLEVEL']
    DATA_WIDTH = param['DATA_WIDTH']
    ADDR_WIDTH = param['ADDR_WIDTH']
    
    text.append("module %s(CLK, WADDR, RADDR, DIN, WE, RE, DOUT);" %TOPLEVEL)
    text.append("\n\tinput CLK, WE, RE;")
    text.append("\n\tinput [%d:0] WADDR, RADDR;" %(ADDR_WIDTH-1))
    text.append("\n\tinput [%d:0] DIN;" %(DATA_WIDTH-1))
    text.append("\n\toutput [%d:0] DOUT;" %(DATA_WIDTH-1))
    text.append("\n\twire CLK, WE, RE;")
    text.append("\n\twire [%d:0] WADDR, RADDR;" %(ADDR_WIDTH-1))
    text.append("\n\twire [%d:0] DIN;" %(DATA_WIDTH-1))
    text.append("\n\twire [%d:0] DOUT;" %(DATA_WIDTH-1))
    text.append("\n\t")

    # MemoryLatch wires
    for i in range(2**ADDR_WIDTH):
        text.append("\n\twire [%d:0] MemoryLatch_%d ;" %((DATA_WIDTH-1),i))

    text.append("\n\t")
    
    # MemoryLatch_reg_row_col instantiation
    for row in range(2**ADDR_WIDTH):
        for col in range(DATA_WIDTH):    
            text.append("\n\t" + cell["latch"]['name']
                + " MemoryLatch_reg_" + str(row) + "_" + str(col)
                + "(." + cell["latch"]['enable'] + " (DGWClk")
            if col < (DATA_WIDTH/2):
                text[len(text)-1] += "Left"
            else:
                text[len(text)-1] += "Right"
            text[len(text)-1] += ('Net_' + str(row) + '), '
                '.'+cell["latch"]['input']+' (GDIN['+str(col)+']), '
                '.'+(cell["latch"]['output']+' (MemoryLatch_'+str(row)+'['+str(col)+']));'))

    text.append("\nendmodule")    

def write_module_read_mux():
    pass    

def write_module_row_decoder():
    pass    


if __name__ == '__main__':
    main()
